## 一、排序算法的介绍

> ==简介==

排序也称排序算法 (Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。

**排序的分类：**

1) 内部排序:

   指将需要处理的所有数据都加载到内部存储器中进行排序。

2) 外部排序法：

   数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。

3) 常见的排序算法分类(见下图):

 ![image-20220111171532272](https://gitee.com/lovely-hair/blog-img/raw/master/img/20220111171539.png)

## 二、算法的时间复杂度

### 1、**度量一个程序**(**算法**)**执行时间的两种方法**

1)事后统计的方法

这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等

环境因素, **这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快**。

2)事前估算的方法

通过分析某个算法的**时间复杂度**来判断哪个算法更优.

> 一般使用事前估算法，因为更加方便，可靠

### 2、算法的时间复杂度介绍及其特点

#### 2.1、时间频度

> ==介绍==

**时间频度**：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。**一个算法中的语句执行次数称为语句频度**

**或时间频度**。记为T(n)。

> ==基本案例==

比如计算1-100所有数字之和, 我们设计两种算法：

 ![image-20220111172416095](https://gitee.com/lovely-hair/blog-img/raw/master/img/20220111172416.png)

第一种循环了100次（total += i），然后最后进行了一次i <= end ,所以是 n + 1.

第二种只进行了一次 运算，所以 是 1.

#### 2.2、低次项可忽略

 ![image-20220111172814611](https://gitee.com/lovely-hair/blog-img/raw/master/img/20220111172814.png)

 ![image-20220111172831677](https://gitee.com/lovely-hair/blog-img/raw/master/img/20220111172831.png) 

结论: 

1)2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10

2)n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20

#### 2.3、忽略系数

 ![image-20220111173013102](https://gitee.com/lovely-hair/blog-img/raw/master/img/20220111173013.png)

结论: 

1)随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明 这种情况下, 5和3可以忽略。

2)而n^3+5n 和 6n^3+4n ，执行曲线分离，说明多少次方式关键

#### 2.4、时间复杂度

1)一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，

T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。

2)T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。

3)计算时间复杂度的方法：

•用常数1代替运行时间中的所有加法常数 T(n)=n²+7n+6 => T(n)=n²+7n+1

•修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 => T(n) = n²

•去除最高阶项的系数 T(n) = n² => T(n) = n² => O(n²)

### 3、常见时间复杂度分类

#### 3.1、常见的时间复杂度

 ![image-20220111180608382](https://gitee.com/lovely-hair/blog-img/raw/master/img/20220111180608.png)

**说明**：

•常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜Ο(nk)＜Ο(2n) ，随着问题规模n的不断增大，上述时间复杂度		不断增大，算法的执行效率越低

•从图中可见，我们应该尽可能避免使用指数阶的算法

#### 3.2、常数阶 O(1)

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)

```java
int i = 1;
int j = 1;
++i;
j++;
int m = i + j;
```

上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

#### 3.3、对数阶 O(log2n)

```java
int i = 1;
while(i < n){
    // 关注点 每次是 * 2，不是 ++
    i = i * 2;
}
```

 ![image-20220111181523763](https://gitee.com/lovely-hair/blog-img/raw/master/img/20220111181523.png)

#### 3.4、线性阶 O(n)

```java
int j = 1;
for(int i = 0; i < n; i++){
    j++;
}
```

#### 3.5、线性对数阶 O(nlog2n)

 ![image-20220111181909252](https://gitee.com/lovely-hair/blog-img/raw/master/img/20220111181909.png)

**说明**：线性对数阶O(nlog2n) 其实非常容易理解，将时间复杂度为O(log2n)的代码循环N遍的话，那么它的时间复杂度就是 n * O(log2n)，也就是了O(nlog2n)

#### 3.6、平方阶 O(n2)

 ![image-20220111182048551](https://gitee.com/lovely-hair/blog-img/raw/master/img/20220111182048.png)

#### 3.7、6)**立方阶**O(n³)**、**K次方阶O(n^k)

**说明**：参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似

### 4、平均时间复杂度与最坏时间复杂度

1)平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。

2)最坏情况下的时间复杂度称最坏时间复杂度。==一般讨论的时间复杂度均是最坏情况下的时间复杂度。== 

这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。

3)平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。

 ![image-20220111182306734](https://gitee.com/lovely-hair/blog-img/raw/master/img/20220111182306.png)

## 三、算法的空间复杂度

1)类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。

2)空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，

它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况

3)在做算法分析时，**主要讨论的是时间复杂度**。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质

就是用空间换时间.